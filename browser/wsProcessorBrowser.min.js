class wsProcessor{constructor(e,t,s,i,a=((e,t)=>{}),o={},r=(e=>{})){this.stackNote={},this.stackRequest={},this.stackResponse={},this.sendingFunc=e,this.closingFunc=t,this.logger=a,this.cbTest=r,"openOnConstruct"in o||(o.openOnConstruct=!0),this.closing=!0,this.incomingNoteFunc=s,this.incomingRequestFunc=i,this.heartbeat={},this.heartbeat.minInterval=o.heartbeatMinInterval||2,this.heartbeat.rttIntervalMultiplicator=o.heartbeatRttIntervalMultiplicator||10,this.heartbeat.minTimeout=o.heartbeatMinTimeout||10,this.heartbeat.rttTimeoutMultiplicator=o.heartbeatRttTimeoutMutiplicator||50,this.heartbeat.lastRTT=.1,this.heartbeat.currentRTT=.1,this.heartbeat.nSent=0,this.heartbeat.nLastArrived=0,this.heartbeat.sent={},this.heartbeat.timeoutNext=void 0,o.openOnConstruct&&this.open()}open(){this.closing=!1,this.sendHeartbeat()}close(e=!1){if(!this.closing){e&&this.closingFunc(),this.closing=!0,clearTimeout(this.heartbeat.timeoutNext);for(let e in this.heartbeat.sent)clearTimeout(this.heartbeat.sent[e].timeout);this.heartbeat.sent={};for(let e in this.stackNote)clearTimeout(this.stackNote[e].ackTimeoutHandle),this.stackNote[e].cbAck(1,"Connection closed before noteAck arrived.");this.stackNote={};for(let e in this.stackRequest){let t=this.stackRequest[e];t.ackTimeoutHandle&&clearTimeout(t.ackTimeoutHandle),clearTimeout(this.stackRequest[e].requestTimeoutHandle),t.opt.sendAck?t.opt.ackArrived?t.cbFailure(1.1,"Connection closed before response arrived, but after successful acknowledgement."):t.opt.ackTimeout>0?t.opt.ackTimedOut?t.cbFailure(1.3,"Connection closed before response arrived and after the acknowledgement did not arrive within the timeout."):t.cbFailure(1.2,"Connection closed before response arrived and before the acknowledgement timed out."):t.cbFailure(1.2,"Connection closed before response arrived and before acknowledgement."):t.cbFailure(1,"Connection closed before response arrived.")}this.stackRequest={};for(let e in this.stackResponse)this.stackResponse[e].ackTimeoutHandle&&clearTimeout(this.stackResponse[e].ackTimeoutHandle),this.stackResponse[e].cbAck(1,"Connection closed before responseAck arrived.");this.stackResponse={},this.logger(0,"The ws connection got closed.")}}sendHeartbeat(){let e=++this.heartbeat.nSent,t={};this.heartbeat.sent["H"+e]=t;var s={type:"ping"};s.data=e;let i=JSON.stringify(s),a=new Date;t.time=a.getTime(),this.sendingFunc(i),this.logger(4,`Ping sent ${e}`);let o=(this.heartbeat.lastRTT+this.heartbeat.currentRTT)/2,r=1e3*Math.max(this.heartbeat.minTimeout,this.heartbeat.rttTimeoutMultiplicator*o);t.timeout=setTimeout(()=>{delete this.heartbeat.sent["H"+e],this.logger(0,`Pong did not arrive within the timeout of ${r/1e3}s. Pong nbr: ${e}`),this.close(!0)},r);let n=1e3*Math.max(this.heartbeat.minInterval,this.heartbeat.rttIntervalMultiplicator*o);this.heartbeat.timeoutNext=setTimeout(()=>{this.sendHeartbeat()},n)}sendError(e){var t={type:"error"};t.data=e;let s=JSON.stringify(t);this.logger(3,`Error sent per ws: ${s}`),this.sendingFunc(s)}sendNote(e,t={},s=((e,t)=>{})){t.sendAck=t.sendAck||!1,t.ackTimeout=t.ackTimeout||5;var i=this.uuidv4(),a={type:"note"};a.sendAck=t.sendAck,a.stamp=i,a.data=e;let o=JSON.stringify(a);if(t.sendAck){let e={};e.cbAck=s,e.message=o,e.stamp=i,e.opt=t,this.stackNote[i]=e,e.ackTimeoutHandle=setTimeout(()=>{let s=`No ack arrived within the timeout (${t.ackTimeout}s) of message ${e.message}. `;e.cbAck(2,s),this.logger(1,s),delete this.stackNote[i]},1e3*t.ackTimeout)}this.logger(3,`NoteAck sent per ws: ${o}`),this.sendingFunc(o)}sendRequest(e,t=(e=>{}),s=((e,t)=>{}),i={},a=((e,t)=>{})){i.requestTimeout=i.requestTimeout||10,i.sendAck=i.sendAck||!1,i.ackTimeout=i.ackTimeout||0;var o=this.uuidv4();let r={type:"request"};r.sendAck=i.sendAck,r.stamp=o,r.data=e;let n=JSON.stringify(r),c={};c.cbSuccess=t,c.cbFailure=s,c.cbAck=a,c.message=n,c.stamp=o,c.opt=i,this.stackRequest[o]=c,c.requestTimeoutHandle=setTimeout(()=>{let e;c.opt.sendAck?c.opt.ackArrived?(e=`No response arrived within the timeout (${i.requestTimeout}s), after the ack did arrive of message ${c.message}.`,c.cbFailure(2.1,e)):c.opt.ackTimeout>0?c.opt.ackTimedOut?(e=`No response arrived within the timeout (${i.requestTimeout}s)  and also no ack arrived within the ackTimeout (${i.ackTimeout}s) of message ${c.message}. `,c.cbFailure(2.3,e)):(clearTimeout(c.ackTimeoutHandle),e=`No response arrived within the timeout (${i.requestTimeout}s), but the ackTimeout (${i.ackTimeout}s) did not yet time out (should not happen, since the ackTimeout should always be smaller than the requestTimeout) of message ${c.message}. `,c.cbFailure(2.2,e)):(e=`No response arrived within the timeout (${i.requestTimeout}s) and also no ack arrived so far of message ${c.message}. `,c.cbFailure(2.2,e)):(e=`No response arrived within the request timeout (${i.requestTimeout}s) of message ${c.message}. `,c.cbFailure(2,e)),this.logger(1,e),delete this.stackRequest[c.stamp]},1e3*i.requestTimeout),i.sendAck&&(i.ackArrived=!1),i.ackTimeout>0&&i.sendAck&&(i.ackTimedOut=!1,c.ackTimeoutHandle=setTimeout(()=>{let e=`No ack arrived within the timeout (${i.ackTimeout}s) of message ${c.message}. `;c.cbAck(1,e),this.logger(1,e),delete c.ackTimeoutHandle,i.ackTimedOut=!0},1e3*i.ackTimeout)),this.logger(3,`Request sent per ws: ${n}`),this.sendingFunc(n)}uuidv4(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){var t=16*Math.random()|0;return("x"==e?t:3&t|8).toString(16)})}onMessage(e){this.logger(4,"Message recieved per ws: "+e);var t={};try{t=JSON.parse(e)}catch(t){let s=`Message could not be parsed: ${e}`;this.sendError(s),this.logger(0,s)}if(!("type"in t)){let t='Message has no "type"-property and thus is deleted/dropped: '+e;return this.logger(0,t),void this.sendError(t)}if(!this.cbTest(t)){var s={note:()=>{if(t.sendAck){let e={type:"noteAck"};e.stamp=t.stamp,this.sendingFunc(JSON.stringify(e))}this.incomingNoteFunc(t.data)},noteAck:()=>{if(t.stamp)if(t.stamp in this.stackNote){let e=this.stackNote[t.stamp];e.cbAck(0,"Note successfully acknowledged."),clearTimeout(e.ackTimeoutHandle),delete this.stackNote[t.stamp]}else{let s=`Stamp ${t.stamp} was not on stack. This happens when 1) (unlikely) somebody tries to hack you or 2) (likely) the server was very busy and could not send you an answer within you default waiting time so you sent the requst again and the server finally also processed every request (n-1 times for nothing...) or 3) (little likely) two responses were sent for the same request and thus the request was already removed from the stack. It is not allowed to have more than one response (currently) and thus the now received (second or later) response is unhandled/deleted. Message: ${e}`;this.logger(0,s),this.sendError(s)}else{let t="NoteAck is not valid without stamp: "+e;this.sendError(t),this.logger(0,t)}},request:()=>{if(void 0!=t.data&&void 0!=t.stamp){if(this.closing)return;if(t.sendAck){let e={type:"requestAck",stamp:t.stamp},s=JSON.stringify(e);this.sendingFunc(s)}let e=(e,s=0,i={},a=((e,t)=>{}))=>{i.sendAck=i.sendAck||!1,i.ackTimeout=i.ackTimeout||5;let o={type:"response"};o.sendAck=i.sendAck,o.stamp=t.stamp,o.data=e,o.failureCode=s;let r=JSON.stringify(o),n={};if(i.sendAck&&(n.opt=i,n.stamp=t.stamp,n.response=e,n.cbAck=a,n.message=r,this.stackResponse[t.stamp]=n),this.closing)return a(3,`The connection was closed before the response (${r}) was sent.`),void(i.sendAck&&delete this.stackResponse[n.stamp]);i.sendAck&&(n.ackTimeoutHandle=setTimeout(()=>{let e=`The following response timed out and is now considered failed: ${n.message}`;this.logger(1,e),n.cbAck(2,e),delete this.stackResponse[n.stamp]},1e3*i.ackTimeout)),this.sendingFunc(r)};this.incomingRequestFunc(t.data,e)}else{let t="Request is not valid without stamp and data properties: "+e;this.sendError(t),this.logger(0,t)}},requestAck:()=>{if(!("stamp"in t)){let t=`Could not process requestAck because not all necessary properties were set: ${e}`;return this.logger(0,t),void this.sendError(t)}let s;if(!(s=this.stackRequest[t.stamp])){let t=`Could not process requestAck because it is not on the stack: ${e}`;return this.logger(0,t),void this.sendError(t)}if(s.opt.ackTimedOut){let e=`Acknowledgement arrived after it has timed out. It is ignored. Stamp: ${t.stamp}`;return this.logger(0,e),void this.sendError(e)}s.cbAck(0,"Request successfully acknowledged."),clearTimeout(s.ackTimeoutHandle),s.opt.ackArrived=!0},response:()=>{if(void 0!=t.data&&void 0!=t.stamp){let s;if(!(s=this.stackRequest[t.stamp])){let t=`Stamp was not on stack. This happens when 1) (unlikely) somebody tries to hack you or 2) (likely) the server was very busy and could not send you an answer within your default waiting time so you sent the requst again and the server finally also processed every request (n-1 or even n times (when none of the replys came within the time between the first and the last request) for nothing...) or 3) (little likely) two responses were sent for the same request and thus the request was already removed from the stack. It is not allowed to have more than one response (currently) and thus the now received (second or later) response is unhandled/deleted. Message: ${e}`;return this.logger(0,t),void this.sendError(t)}if(clearTimeout(s.requestTimeoutHandle),t.sendAck){let e={type:"responseAck",stamp:t.stamp},s=JSON.stringify(e);this.sendingFunc(s)}t.failureCode?s.cbFailure(t.failureCode,t.data):s.cbSuccess(t.data),delete this.stackRequest[t.stamp]}else{let t="Response is not valid without stamp and data properties: "+e;this.sendError(t),this.logger(0,t)}},responseAck:()=>{if(!("stamp"in t)){let t=`Could not process responseAck because not all necessary properties were set: ${e}`;return this.logger(0,t),void this.sendError(t)}let s;if(!(s=this.stackResponse[t.stamp])){let t=`Could not process responseAck because it is not on the stack: ${e}`;return this.logger(0,t),void this.sendError(t)}clearTimeout(s.ackTimeoutHandle),s.cbAck(0,"Response successfully acknowledged."),delete this.stackResponse[s.stamp]},error:()=>{this.logger(1,"A client returned an error for a ws-package: "+t.data.toString())},ping:()=>{let e={type:"pong"};e.data=t.data,this.sendingFunc(JSON.stringify(e)),this.logger(4,`Ping ${t.data} arrived. Pong sent.`)},pong:()=>{let e=this.heartbeat.sent["H"+t.data];if(void 0===e)return void this.logger(1,"Pong message did not match a sent ping. Pong is ignored.");let s=(new Date).getTime()-e.time;clearTimeout(e.timeout),this.heartbeat.lastRTT=this.heartbeat.currentRTT,this.heartbeat.currentRTT=s/1e3,this.heartbeat.nLastArrived+1!=t.data&&this.logger(1,`Pong ${t.data} arrived out of order. Last pong was ${this.heartbeat.nLastArrived}`),this.heartbeat.nLastArrived=t.data,delete this.heartbeat.sent["H"+t.data],this.logger(4,`Pong ${t.data} arrived within ${s} ms.`)}};"function"==typeof s[t.type]?s[t.type]():this.logger(1,t.type+" is not a supported type of WebSocket data.")}}}